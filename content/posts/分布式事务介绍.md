## 分布式事务介绍

[TOC]



### 分布式事务是什么？

随着微服务架构的流行，应用对应的数据存储在不同的数据库中，而分布式事务是为了保证分布式数据库一致性的解决方案。换句话说，是保证分布式数据库操作的原子性。

### 数据为什么会出现不一致？

微服务的架构设计：

+ 分表 - 本地事务可保持数据一致

  为什么会分表？

  单表的数据过大

+ 分库 - 网络延迟 网络故障

  为什么会分库？

  物理机的资源竞争，会导致性能瓶颈

+ 业务服务化 - 微服务

### 解决数据不一致方案

+ 强一致性解决方案
  + 两阶段提交协议
  + 三阶段提交协议
+ 最终一致性解决方案
  + 补偿模式
  + 可靠事件模式

### 两阶段提交协议（2PC - Two-Phase Commit）- 强一致

#### 角色

+ 参与者
+ 协调者

#### 过程

+ 准备阶段

  + 协调者节点会对各个节点发起询问：是否可执行事务提交操作
  + 参与者节点收到询问后，如果可以执行，锁定资源，并将信息写入redo/undo log。执行事务但不提交
  + 参与者将执行事务情况反馈给协调者

+ 执行阶段

  + 第一种情况：参与者响应可正常执行事务

    协调者向各个参与者发送 commit 通知，请求提交事务。

    参与者收到通知，则进行事务提交，释放占用资源。

  + 第二种情况：一个或多个参与者响应事务执行失败。或者协调者超时等待

    协调者向各个参与者发送 rollback 通知，请求回滚事务。

    参与者收到通知，则回滚事务，释放占用资源。

  ![2pc-success](https://segmentfault.com/img/bV0KNR)

#### 状态的变化

![image-20210225141855386](../Library/Application Support/typora-user-images/image-20210225141855386.png)

**协调者**

+ 发送事务投票 -> wait 
+ 根据收到参与者回复 -> 决定发送 rollback | commit

**参与者**

+ 收到协调者的投票请求，当参与者事务执行完成并响应完协调者之后，进入 ready 状态
+ 收到协调者 rollback | commit 请求，执行队对应动作

#### 问题

+ 同步阻塞

  在两阶段提交执行过程中，所有的参与者都需要听从协调者的统一调度，期间处于阻塞状态，特别是当节点占用某项资源时，此时其他节点需要访问这项资源时，也会连带进入阻塞。

+ 数据不一致

  在协调者通知各个参与者进行事务的提交时，可能会由于网络原因，仅通知了一部分参与者。此时就会出现了数据的不一致。

#### 问题的可能解决方案

**超时机制**：在协调者进入 Wait 状态时，如若超时未收到全部参与者的响应，则进行发起 rollback 请求。

**互询机制**：在参与者进入 Ready 状态时，有节点超时未收到协调者的请求时，则可以向其他节点发起询问，事务是否 rollback，如果 rollback 了，则本节点进行回滚，否则不能做操作，因为询问结果是 commit，并不能保证其他节点是否是 commit

#### 二阶段协议的实现

XA协议，作为资源管理器（数据库）与事务管理器的接口标准

### 三阶段提交协议（3PC - Three-Phase Commit）- 强一致

为解决二阶段提交问题而设计的，引入了 can_commit 阶段和超时机制，目的是缩短阻塞时间

#### 过程

+ 预询盘 - can_commit

  + 协调者向各个节点发起询问：是否可以执行事务操作
  + 参与者根据自身情况进行响应，如果可以，参与者则进入预备状态

+ 预提交 - pre_commit

  + 预询盘结果 - 所有参与者返回正确响应
    + 协调者向参与者发送事务执行通知
    + 参与者执行事务但不提交
    + 参与者将执行情况返回给协调者
  + 预询盘结果 - 一个或部分参与者返回否定响应 或者 协调者超时等待
    + 协调者向参与者发送 abort 通知
    + 参与者收到通知后中断事务

  ![3pc-fail-1](https://segmentfault.com/img/bV0KOZ)

+ 事务提交 - do_commit

  + 所有参与者正常执行事务

    + 协调者向所有参与者发送 commit 通知
    + 所有参与者在收到通知之后执行 commit 操作，并释放占有的资源；
    + 参与者向协调者反馈事务提交结果

    ![3pc-success](https://segmentfault.com/img/bV0KO7)

  + 一个或者部分执行事务失败 或者 协调者等待超时

    + 协调者向所有参与者发送 rollback 通知
    + 所有参与者在收到通知之后执行 rollback 操作，并释放占有的资源；
    + 参与者向协调者反馈事务回滚结果

    ![3pc-fail-2](https://segmentfault.com/img/bV0KPw)

  + 参与者等待超时

    由于网络原因，参与者可能会收不到协调者的 commit 或者 rollback 的请求，当超过参与者的等待超时时间，那么参与者不会再继续阻塞了，直接进行 commit ，虽然降低了同步阻塞，但是无法避免数据的不一致。

#### 状态的变化

![image-20210225180204356](../Library/Application Support/typora-user-images/image-20210225180204356.png)

**协调者**

+ 协调者发送预询盘 -> Wait
+ 接受到参与者部分失败 -> Abort
+ 接收到参与者全部成功 -> 发送 PRE_COMMIT 
+ 接收到参与者部分失败 -> Rollback
+ 接收到参与者全部成功 -> Commit

**参与者**

+ 参与者接收到预询盘，如果评估完可以进行事务，则进入 Ready，否则，则返回失败给协调者
+ 接收到协调者 abort -> 进行中断事务
+ 接收到协调者 pre_commit 请求 , 如果执行事成功 ，则发送成功给协调者， 否则发送失败
+ 接收到协调者 commit | rollback，执行对应请求

#### 问题

+ 数据不一致

  和二阶段一样会存在数据不一致的情况，不一样的是，三阶段中加入了超时机制，参与者在等待超时后，会默认进行 commit，这就可能会导致了数据不一致。

+ 相对于二阶段，网络调用次数增多，耗时增长

#### 优点

+ 增加询问阶段，尽早发现无法执行操作而需要终止的行为，减少此种情况的发生，但无法避免
+ 降低阻塞范围，因为超时机制，并能够在出现单点故障后继续达成一致

### 案例

#### Mysql 事务

1. 采用的方案：遵循使用二阶段提交协议的 [XA规范](https://zh.wikipedia.org/wiki/X/Open_XA)

2. 为什么 Mysql 需要二阶段提交协议，来保证数据一致性？

   因为 Mysql 事务采用 [WAL](https://zh.wikipedia.org/wiki/%E9%A2%84%E5%86%99%E5%BC%8F%E6%97%A5%E5%BF%97) 保证原子性和持久性，而日志涉及到两个层面的日志，存储引擎层的 redo/undo log 和 Mysql Server 层的 bin log，采用两阶段提交，是为了保证两层日志逻辑保持一致。

3. 事务提交流程

   + 第一阶段 prepare 阶段
     + Binlog - do nothing
     + Innodb - 设置事务状态为 prepare，并记录 undo/redo log
   + 第二阶段 提交
     + Binlog -  写日志
     + innodb - 清除undo信息，刷redo日志，设置事务状态为 commit

   

### CAP 理论 - 分布式系统

#### 概念

**C - Consistency** 

一致性。分布式系统下，一份数据可能有多个数据副本。在正常修改数据前后，访问各个节点该数据，保持一致。

**A - Availability**

可用性。应用服务在有限时间内返回响应结果。微服务可用性，可以用 SLA（Service-Level Agreement） 来衡量。

**P - Partition Tolerance**

分区容错性。

网络分区，不同的网络节点组成的子网络（异地或机房），子网络之间因为某些原因不能无法连通，这就造成了分区。

如果你的数据，只存在某些节点上，那么和这个节点不连通的部分，访问不到，这时候分区无法容忍。

提高分区容错性的办法是，把此数据在各个节点都存一份，这时候对分区容忍性就提高了。

![image-20210224142124245](../Library/Application Support/typora-user-images/image-20210224142124245.png)

#### 问题

1. 为什么 P 是前提，C|A 选一个？

   反证法。数据服务的分区容忍不具备的话，出现了分区，服务都不可用，那其他无从说起。所以分布式系统，必须以P为前提，其他两个在设计架构时候取舍。如果选择 C , 那么分布式系统必然要保证强一致，但是可能会导致系统不可用。如果选择 A，那么分布式系统要保证可用性，但不保证强一致性。

2. CAP 的一致性 和 ACID 一致性的区别？

### BASE 理论 - 面向大型高可用可扩展的分布式系统

#### 概念

**Basically Available（基本可用）** - 牺牲部分可用性

**Soft state（软状态）** - 允许系统中的数据存在中间状态, 即即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时

**Eventually consistent（最终一致性）** 

#### CAP 关联

A&P -> BASE 理论 - 最终一致

C&A -> ACID 理论 - 强一致

### 最终一致性解决方案 - TCC（Try-Confirm-Cancel）

#### 流程

#### 举例

冻结 扣除回滚

#### 问题

具有侵入性

#### 和 2PC 的区别

+ 没有 TM-事务管理器

#### 异常情况

1. 空回滚
2. 幂等
3. 悬挂

### 最终一致性解决方案 - 补偿机制

#### 重试机制

+ 异步重试：MQ、定时任务
+ 同步重试：httpClient

#### 定时机制

定时任务进行定时重试及定时核对

工具：xxl-job、elastic-job

#### 更新修复

自我修正，减瞬时压力。

场景举例：比如文章的收藏数，数据库 + 缓存，用户每次收藏动作更新数据库，但是此时不会更新缓存。等到用户访问时，发现文章的缓存超过了24h，则进行刷新数据。减少了，用定时任务统一刷新的数据量

### 最终一致性解决方案 - 可靠事件模式

#### 流程

记录事件消息 -> 业务逻辑事务提交 -> 事件发送 -> 发送成功 标记事件发送成功 -> 服务B 消费成功后 发送事件消费成功消息 ->  消息消费 标记事件 消费成功

补偿：定时任务 扫描数据库 消息消费失败事件，重新发送

![image-20210303135516952](../Library/Application Support/typora-user-images/image-20210303135516952.png)

#### 问题

1. 消息的幂等性

   + 消息逻辑非幂等

     说明消息不能被重复消费，消息中间件都不能保证，那么需要考虑怎么保证消息仅仅被消费一次

   + 消息幂等

     消息能够重复发送，此时需要注意，消息的顺序性。

2. 怎么保证消息的顺序性

   + 状态机
   + 时间戳
   + 全局递增序列号

### 最终一致性解决方案 - 事务消息

RocketMQ 的事务消息，其机制类似 XA 分布式事务的功能。

目的：本地事务 和 消息发送的一致

保证机制：回查

![image-20210303152155530](../Library/Application Support/typora-user-images/image-20210303152155530.png)

参考：

+ https://segmentfault.com/a/1190000012534071
+ CAP 理论十二年回顾："规则"变了 https://www.infoq.cn/article/cap-twelve-years-later-how-the-rules-have-changed/?itm_source=infoq_en&itm_medium=link_on_en_item&itm_campaign=item_in_other_langs
+ Mysql 两阶段提交：https://www.cnblogs.com/hustcat/p/3577584.html
+ 极客时间-Mysql
+ http://blog.itpub.net/29018063/viewspace-2093311/
+ 可靠事件模式 - http://www.uml.org.cn/wfw/201712153.asp
+ 如何保证消息被消费一次：https://cloud.tencent.com/developer/article/1597358
+ RocketMQ 事务消息：https://help.aliyun.com/document_detail/43348.html
+ RocketMQ 问题汇总：https://www.cnblogs.com/javazhiyin/p/13327925.html 



大纲：

1. 什么是分布式事务
2. 解决什么问题
3. 理论解决方案及案例
4. 实际处理及场景
5. 延伸
   + spring 事务
   + mysql的隔离机制和事务的关系



问题：

![image-20210303153111927](../Library/Application Support/typora-user-images/image-20210303153111927.png)

